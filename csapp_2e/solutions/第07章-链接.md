# [本章书上的例子在这里](./src/ch07)



# 7.6


>     考虑下面的 swap.c 函数版本，它计算自己被调用的次数：

>     1  extern int buf[];
>     2
>     3  int *bufp0 = &buf[0];
>     4  static int *bufp1;
>     5
>     6  static void incr()
>     7  {
>     8      static int count = 0;
>     9
>     10      count++;
>     11  }
>     12
>     13  void swap()
>     14  {
>     15      int temp;
>     16
>     17      incr();
>     18      bufp1 = &buf[1];
>     19      temp = *bufp0;
>     20      *bufp0 = *bufp1;
>     21      *bufp1 = temp;
>     22  }

>     对于每个 swap.o 中定义和引用的符号，请指出它是否在模块 swap.o 的 .symtab 节中有
>     符号表条目。如果是这样，请指出定义该符号的模块（swap.o 或 main.o）、符号类型（本
>     地、全局或外部）以及它在模块中所处的节（.text、.data 或 .bss）。

>     |-------+----------------------+----------+----------------+-------|
>     | 符号  | .swap.o.symtab条目？ | 符号类型 | 定义符号的模块 | 节    |
>     |-------+----------------------+----------+----------------+-------|
>     | buf   |          Y           |  extern  | main.o         | .data |
>     |-------+----------------------+----------+----------------+-------|
>     | bufp0 |          Y           |  global  | swap.o         | .data |
>     |-------+----------------------+----------+----------------+-------|
>     | bufp1 |          Y           |  local   | swap.o         | .bss  |
>     |-------+----------------------+----------+----------------+-------|
>     | swap  |          Y           |  global  | swap.o         | .text |
>     |-------+----------------------+----------+----------------+-------|
>     | temp  |          N           |          |                |       |
>     |-------+----------------------+----------+----------------+-------|
>     | incr  |          Y           |  local   | swap.o         | .text |
>     |-------+----------------------+----------+----------------+-------|
>     | count |          Y           |  local   | swap.o         | .data |
>     |-------+----------------------+----------+----------------+-------|


# 7.7

>     不改变任何变量名字，修改 7.6.1 节中的 bar5.c，使得 foo5.c 输出 x 和 y 的正确
>     值（也就是整数 15213 和 15212 的十六进制表示）。

f的函数注释掉即可。


# 7.8

>     在此题中，REF(x,i) --> DEF(x,k) 表示链接器将任意对模块 i 中符号 x 的引用与模
>     块 k 中符号 x 的定义相关联。在下面每个例子中，用这种符号来说明链接器是如何解
>     析在每个模块中有多重定义的引用的。如果出现链接时错误（规则 1），写“ERROR”。
>     如果链接器从定义中任意选择一个（规则 3），那么写“UNKNOWN”。

>     A. /* Module 1*/                /* Module 2 */
>        int main()                   static int main = 1;
>        {                            int p2()
>        }                            {
>                                     }

>     a) REF(main.1) --> DEF(____.____)
>     b) REF(main.2) --> DEF(____.____)

>     B. /* Module 1 */               /* Module 2 */
>        int x;                       double x;
>        void main()                  int p2()
>        {                            {
>        }                            }

>     a) REF(x.1) --> DEF(____.____)
>     b) REF(x.2) --> DEF(____.____)

>     C. /* Module 1 */               /* Module 2 */
>        int x = 1;                   double x = 1.0;
>        void main()                  int p2()
>        {                            {
>        }                            }

>     a) REF(x.1) --> DEF(____.____)
>     b) REF(x.2) --> DEF(____.____)

```
A.
// 第二个文件中是对外不可见的static
a) REF(main.1) --> DEF(main.1) 
b) REF(main.2) --> DEF(main.2)

B.

a) REF(x.1) --> DEF(x.UNKNOWN)
b) REF(x.2) --> DEF(x.UNKNOWN)

C.

a) REF(x.1) --> DEF(x.ERROR)
b) REF(x.2) --> DEF(x.ERROR)
```

# 7.9

>     考虑下面的程序，它由两个目标模块组成：

>     1 /* foo6.c */            1 /* bar6.c */
>     2 void p2(void);          2 #include <stdio.h>
>     3                         3
>     4 int main()              4 char main;
>     5 {                       5
>     6     p2();               6 void p2()
>     7     return 0;           7 {
>     8 }                       8     printf("0x%x\n", main);
>                               9 }

>     当在 Linux 系统中编译和执行这个程序时，即使 p2 不初始化变量 main，它也能打印字符
>     串“0x55\n”并正常终止。你能解释这一点吗？

左边的是弱符号，右边的是强符号。

在 bar6.c 中的打印语句中，将会打印 main 函数的第一个字节的值。在 IA32 中，
函数的第一条指令通常是压栈指令：

    pushl %ebp

机器码就是 0x55

# 7.10

>      a 和 b 表示当前路径中的目标模块或静态库，而 a->b 表示 a 依赖于 b，也就是说a
>      引用了一个 b 定义的符号。对于下面的每个场景，给出使得静态链接器能够解析所有
>      符号引用的最小的命令行（含有最少数量的目标文件和库参数的命令）：

>      A. p.o -> libx.a -> p.o
>      B. p.o -> libx.a -> liby.a 和 liby.a -> libx.a
>      C. p.o -> libx.a -> liby.a 和 liby.a -> libx.a -> libz.a

```
A. gcc -static p.o libx.a
B. gcc -static p.o libx.a liby.a libx.a
C. gcc -static p.o libx.a liby.a libx.a libz.a
```

# 7.11

>      图 7-12 中的段头部表明数据段占用了存储器中 0x104 个字节。然后，只有开始的
>      0xe8 字节来自可执行文件的节。引起这种差异的原因是什么？

.bss 未初始化的数据。

# 7.12

>      图 7-10 中的 swap 程序包含 5 个重定位的引用。对于每个重定位的引用，给出它在
>      图 7-10 中的行号、运行时存储器地址和值。swap.o 模块中的原始代码和重定位条目
>      如图7-19 所示。

>      1  0000000 <swap>:
>      2  0: 55                   push %ebp
>      3  1: 8b 15 00 00 00 00    mov 0x0,%edx            ; Get *bufp0 = &buf[0]
>      4                          3: R_386_32 bufp0       ; Relocation entry
>      5  7: a1 04 00 00 00       mov 0x4,%eax            ; Get buf[1]
>      6                          8: R_386_32 buf         ; Relocation entry
>      7  c: 89 e5                mov %esp, %ebp
>      8  e: c7 05 00 00 00 00 04 movl $0x4, 0x0          ; bufp1 = &buf[1];
>      9  15: 00 00 00
>      10                         10: R_386_32 bufp1      ; Relocation entry
>      11                         14: R_386_32 buf        ; Relocation entry
>      12 18: 89 ec               mov %ebp, %esp
>      13 1a: 8b 01               mov (%edx), %ecx        ; temp = buf[0];
>      14 1c: 89 02               mov %eax, (%edx)        ; buf[0] = buf[1];
>      15 1e: a1 00 00 00 00      mov 0x0, %eax           ; Get *bufp1 = &buf[1]
>      16                         1f: R_386_32 bufp1      ; Relocation entry
>      17 23: 89 08               mov %ecx, (%eax)        ; buf[1] = temp;
>      18 25: 5d                  pop %ebp
>      19 26: c3                  ret

>      |------------------+------+----|
>      | 图 7-10 中的符号 | 地址 | 值 |
>      |------------------+------+----|
>      |                  |      |    |
>      |------------------+------+----|
>      |                  |      |    |
>      |------------------+------+----|
>      |                  |      |    |
>      |------------------+------+----|
>      |                  |      |    |
>      |------------------+------+----|
>      |                  |      |    |
>      |------------------+------+----|
>        图 7-19 家庭作业 7.12 的代买和重定位条目

直接看7-10的源码就行。
这个题目其实很简单。
但是能够指导我们进一步理解绝对引用的替换算法。

```
  15  0x80483c8 0x804945c
  16  0x80483d0 0x8049458
  18  0x80483d8 0x8049548
  18  0x80483dc 0x8049458 
  23  0x80483e7 0x8049548
```

# 7.13

>      考虑图 7-20 中的 C 代码和相应的可重定位目标模块。

>      A. 确定当模块被重定位时，链接器将修改 .text 中的哪些指令。对于每条这样的指令，
>         列出它的重定位条目中的信息：节偏移、重定位类型符号名字。

>      B. 确定当模块被重定位时，链接器将修改 .data 中的哪些数据目标。对于每条这样的
>         指令，列出它的重定位条目中的信息：节偏移、重定位类型和符号名字。

>      可以随意使用诸如 objdump 之类的工具来帮助你解答这个题目。

>      ---------------------------------------------------------------------------
>      1  extern int p3(void);
>      2  int x = 1;
>      3  int *xp = &x;
>      4
>      5  void p2(int y) {
>      6  }
>      7
>      8  void p1() {
>      9      p2(*xp + p3());
>      10  }
>      ---------------------------------------------------------------------------
>          a) C 代码

>      ---------------------------------------------------------------------------
>      1  00000000 <p2>:
>      2     0:  55                  push %ebp
>      3     1:  89 e5               mov %esp, %ebp
>      4     3:  89 ec               mov %ebp, %esp
>      5     5:  5d                  pop %ebp
>      6     6:  c3                  ret

>      7  00000008 <p1>:
>      8     8:  55                  push %ebp
>      9     9:  89 e5               mov %esp, %ebp
>      10     b:  83 ec 08            sub $0x8, %esp
>      11     e:  83 c4 f4            add $0xfffffff4, %esp
>      12     11: e8 fc ff ff ff      call 12 <p1+0xa>
>      13     16: 89 c3               mov %eax, %edx
>      14     18: a1 00 00 00 00      mov 0x0, %eax
>      15     1d: 03 10               add (%eax), %edx
>      16     1f: 52                  push %edx
>      17     20: e8 fc ff ff ff      call 21 <p1+0x19>
>      18     25: 89 ec               mov %ebp, %esp
>      19     27: 5d                  pop %ebp
>      20     28: c3                  ret
>      ---------------------------------------------------------------------------
>          b) 可重定位目标文件的 .text 节

>      ---------------------------------------------------------------------------
>      1  00000000 <x>:
>      2     0: 01 00 00 00
>      3  00000004 <xp>:
>      4     4: 00 00 00 00
>      ---------------------------------------------------------------------------
>          c) 可重定位目标文件的 .data 节

>          图 7-20 家庭作业 7.13 的示例代码

.text节中需要替换的部分。
```
  12行。
  0xc  R_386_PC32      p3
   
  14行。
  0x13 R_386_32        xp
   
  17行。
  0x15 R_386_PC32      p2
```

因此给定一个.c文件生成的是本题类似的代码。


拿调用p3举例子。每个需要重新定位的符号都会遍历一遍，他们会有个数据结构，暂且称之为r。

首先我们已经知道了p3的运行时的地址，p3会有个数据结构存放r.offset, r.symbol, r.type。

运行时的地址 = add(.text) + r.offset，所谓的运行时地址也就是调用p3的那个位置的地址。

然后我们也知道r.symbol定义所在的地址，然后简单的运算就行了。


绝对引用同理。

第二题
```
  0x4  R_386_32  x

```

对于绝对引用应该是。

链接器确定所有的全局变量的位置，也就是给出了一个运行时的地址。

然后将运行时的地址加到原来的数值上。(因为这里原来的地址就是0,因此最后的值就是那个绝对值。)


# 7.14

>      考虑图 7-21 中的 C 代码和相应的可重定位目标模块。

>      A. 确定当模块被重定位时，链接器将修改 .text 中的哪些指令。对于每条这样的指令，
>         列出它的重定位条目中的信息：节偏移、重定位类型和符号名字。

>      B. 确定当模块被重定位时，链接器将修改 .rodata 中的哪些数据。对于每条这样的指
>         令，列出它的重定位条目中的信息：节偏移、重定位类型和符号名字。

>      可以随意使用诸如 objdump 之类的工具来帮助你解答这个题目。

>      ----------------------------------------------------------------------------
>      1  int relo3(int val) {
>      2      switch (val) {
>      3      case 100:
>      4          return(val);
>      5      case 101:
>      6          return(val+1);
>      7      case 103: case 104:
>      8          return(val+3);
>      9      case 105:
>      10          return(val+5);
>      11      default:
>      12          return(val+6);
>      13      }
>      14  }
>      ----------------------------------------------------------------------------
>          a) C 代码

>      ----------------------------------------------------------------------------
>      1  00000000 <relo3>:
>      2     0:  55                   push %ebp
>      3     1:  89 e5                mov %esp, %ebp
>      4     3:  8b 45 08             mov 0x8(%ebp), %eax
>      5     6:  8d 50 9c             lea 0xffffff9c(%eax), %edx
>      6     9:  83 fa 05             cmp $0x5, %edx
>      7     c:  77 17                ja 25 <relo3+0x25>
>      8     e:  ff 24 95 00 00 00 00 jmp *0x0(,%edx,4)
>      9     15: 40                   jnc %eax
>      10    16: eb 10                jmp 28 <relo3+0x28>
>      11    18: 83 c0 03             add $0x3, %eax
>      12    1b: eb 0b                jmp 28 <relo3+0x28>
>      13    1d: 8d 76 00             lea 0x0(%esi), %esi
>      14    20: 83 c0 05             add $0x5, %eax
>      15    23: eb 03                jmp 28 <relo3+0x28>
>      16    25: 83 c0 06             add $0x6, %eax
>      17    28: 89 ec                mov %ebp, %esp
>      18    2a: 5d                   pop %ebp
>      19    2b: c3                   ret
>      ----------------------------------------------------------------------------
>          b) 可重定位木条文件的 .text 节

>      ----------------------------------------------------------------------------
>         This is the jump table for the switch statement
>      1  0000 28000000 15000000 25000000 18000000 4 words at offsets 0x0,0x4,0x8,and 0xc
>      2  0010 18000000 20000000                   2 words at offsets 0x10 and 0x14
>      ----------------------------------------------------------------------------
>          c) 可重定位目标文件的 .rodata 节

>          图 7-21 家庭作业 7.14 的示例代码

TODO:

# 7.15

>      完成下面的任务将帮助你更熟悉处理目标文件的各种工具。

>      A. 在你的系统上，libc.a 和 libm.a 的版本中包含多少目标文件？
>      B. gcc -O2 产生的可执行代码与 gcc -O2 -g 产生的不同吗？
>      C. 在你的系统上，GCC 驱动程序使用的是什么共享库？


```
A. $ libs=$(find /{,usr/}lib -type f -name "libc.a" -o -name "libm.a")
   $ for lib in $lib; do printf "$lib: "; ar t $lib | wc -l; done

B. $ gcc -O2 main.c swap.c -o t
   $ gcc -O2 -g main.c swap.c -o t2
   $ readelf -a t > t.elf
   $ readelf -a t2 > t2.elf
   $ diff -u t.elf t2.elf

C. $ ldd $(which gcc)
```

:question:

[14]

